var e=Object.defineProperty,r=Object.defineProperties,t=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,u=(r,t,n)=>t in r?e(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n,i=(e,r)=>{for(var t in r||(r={}))s.call(r,t)&&u(e,t,r[t]);if(n)for(var t of n(r))a.call(r,t)&&u(e,t,r[t]);return e},c=(e,n)=>r(e,t(n));import{r as o,c as l}from"./vendor.029ff854.js";import{F as f,R as d}from"./FieldSet.dc0066e3.js";import{a as m}from"./index.ed0774d5.js";var g=e=>"checkbox"===e.type,p=e=>e instanceof Date,b=e=>null==e;const h=e=>"object"==typeof e;var v=e=>!b(e)&&!Array.isArray(e)&&h(e)&&!p(e),y=e=>e.substring(0,e.search(/.\d/))||e,x=e=>e.filter(Boolean),k=e=>void 0===e,O=(e,r,t)=>{if(v(e)&&r){const n=x(r.split(/[,[\].]+?/)).reduce(((e,r)=>b(e)?e:e[r]),e);return k(n)||n===e?k(e[r])?t:e[r]:n}};const w="blur",j="onBlur",V="onChange",S="onSubmit",_="onTouched",A="all",C="max",F="min",D="maxLength",R="minLength",N="pattern",T="required",I="validate";var E=(e,r)=>{const t=Object.assign({},e);return delete t[r],t};o.exports.createContext(null).displayName="RHFContext";var B=(e,r,t,n,s=!0)=>e?new Proxy(r,{get:(e,r)=>{if(r in e)return t.current[r]!==A&&(t.current[r]=!s||A),n&&(n.current[r]=!0),e[r]}}):r,M=e=>v(e)&&!Object.keys(e).length,L=e=>Array.isArray(e)?e:[e],P="undefined"!=typeof window&&void 0!==window.HTMLElement&&"undefined"!=typeof document;const U=P?"Proxy"in window:"undefined"!=typeof Proxy;var H=(e,r,t,n,s)=>r?Object.assign(Object.assign({},t[e]),{types:Object.assign(Object.assign({},t[e]&&t[e].types?t[e].types:{}),{[n]:s||!0})}):{},Y=e=>/^\w*$/.test(e),q=e=>x(e.replace(/["|']|\]/g,"").split(/\.|\[/));function $(e,r,t){let n=-1;const s=Y(r)?[r]:q(r),a=s.length,u=a-1;for(;++n<a;){const r=s[n];let a=t;if(n!==u){const t=e[r];a=v(t)||Array.isArray(t)?t:isNaN(+s[n+1])?{}:[]}e[r]=a,e=e[r]}return e}const X=(e,r,t)=>{for(const n of t||Object.keys(e)){const t=O(e,n);if(t){const e=t._f,n=E(t,"_f");if(e&&r(e.name)){if(e.ref.focus&&k(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else v(n)&&X(n,r)}}},z=(e,r={})=>{for(const t in e.current){const n=e.current[t];if(n&&!b(r)){const e=n._f,s=E(n,"_f");$(r,t,e&&e.ref?e.ref.disabled||e.refs&&e.refs.every((e=>e.disabled))?void 0:e.value:Array.isArray(n)?[]:{}),s&&z({current:s},r[t])}}return r};var G=e=>b(e)||!h(e);function J(e,r,t){if(G(e)||G(r)||p(e)||p(r))return e===r;if(!o.exports.isValidElement(e)){const n=Object.keys(e),s=Object.keys(r);if(n.length!==s.length)return!1;for(const a of n){const n=e[a];if(!t||"ref"!==a){const e=r[a];if((v(n)||Array.isArray(n))&&(v(e)||Array.isArray(e))?!J(n,e,t):n!==e)return!1}}}return!0}function K(e,r){if(G(e)||G(r))return r;for(const n in r){const s=e[n],a=r[n];try{e[n]=v(s)&&v(a)||Array.isArray(s)&&Array.isArray(a)?K(s,a):a}catch(t){}}return e}function Q(e,r,t,n,s){let a=-1;for(;++a<e.length;){for(const n in e[a])Array.isArray(e[a][n])?(!t[a]&&(t[a]={}),t[a][n]=[],Q(e[a][n],O(r[a]||{},n,[]),t[a][n],t[a],n)):!b(r)&&J(O(r[a]||{},n),e[a][n])?$(t[a]||{},n):t[a]=Object.assign(Object.assign({},t[a]),{[n]:!0});n&&!t.length&&delete n[s]}return t}var W=(e,r,t)=>K(Q(e,r,t.slice(0,e.length)),Q(r,e,t.slice(0,e.length))),Z=e=>"boolean"==typeof e;function ee(e,r){const t=Y(r)?[r]:q(r),n=1==t.length?e:function(e,r){const t=r.slice(0,-1).length;let n=0;for(;n<t;)e=k(e)?n++:e[r[n++]];return e}(e,t),s=t[t.length-1];let a;n&&delete n[s];for(let u=0;u<t.slice(0,-1).length;u++){let r,n=-1;const s=t.slice(0,-(u+1)),i=s.length-1;for(u>0&&(a=e);++n<s.length;){const t=s[n];r=r?r[t]:e[t],i===n&&(v(r)&&M(r)||Array.isArray(r)&&!r.filter((e=>v(e)&&!M(e)||Z(e))).length)&&(a?delete a[t]:delete e[t]),a=r}}return e}var re=e=>"file"===e.type,te=e=>"select-multiple"===e.type,ne=e=>"radio"===e.type;const se={value:!1,isValid:!1},ae={value:!0,isValid:!0};var ue=e=>{if(Array.isArray(e)){if(e.length>1){const r=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:r,isValid:!!r.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!k(e[0].attributes.value)?k(e[0].value)||""===e[0].value?ae:{value:e[0].value,isValid:!0}:ae:se}return se},ie=(e,{valueAsNumber:r,valueAsDate:t,setValueAs:n})=>k(e)?e:r?""===e?NaN:+e:t?new Date(e):n?n(e):e;const ce={isValid:!1,value:null};var oe=e=>Array.isArray(e)?e.reduce(((e,r)=>r&&r.checked&&!r.disabled?{isValid:!0,value:r.value}:e),ce):ce;function le(e){if(e&&e._f){const t=e._f.ref;if(t.disabled)return;return re(t)?t.files:ne(t)?oe(e._f.refs).value:te(t)?(r=t.options,[...r].filter((({selected:e})=>e)).map((({value:e})=>e))):g(t)?ue(e._f.refs).value:ie(k(t.value)?e._f.ref.value:t.value,e._f)}var r}var fe=(e,r,t,n)=>{const s={};for(const a of e){const e=O(r,a);e&&$(s,a,e._f)}return{criteriaMode:t,names:[...e],fields:s,shouldUseNativeValidation:n}},de=e=>"function"==typeof e,me=e=>"string"==typeof e,ge=e=>me(e)||o.exports.isValidElement(e),pe=e=>e instanceof RegExp;function be(e,r,t="validate"){if(ge(e)||Array.isArray(e)&&e.every(ge)||Z(e)&&!e)return{type:t,message:ge(e)?e:"",ref:r}}var he=e=>v(e)&&!pe(e)?e:{value:e,message:""},ve=async({_f:{ref:e,refs:r,required:t,maxLength:n,minLength:s,min:a,max:u,pattern:i,validate:c,name:o,value:l,valueAsNumber:f,mount:d}},m,p)=>{if(!d)return{};const h=r?r[0]:e,y=e=>{p&&h.reportValidity&&(h.setCustomValidity(Z(e)?"":e||" "),h.reportValidity())},x={},k=ne(e),O=g(e),w=k||O,j=(f||re(e))&&!e.value||""===l||Array.isArray(l)&&!l.length,V=H.bind(null,o,m,x),S=(r,t,n,s=D,a=R)=>{const u=r?t:n;x[o]=Object.assign({type:r?s:a,message:u,ref:e},V(r?s:a,u))};if(t&&(!w&&(j||b(l))||Z(l)&&!l||O&&!ue(r).isValid||k&&!oe(r).isValid)){const{value:e,message:r}=ge(t)?{value:!!t,message:t}:he(t);if(e&&(x[o]=Object.assign({type:T,message:r,ref:h},V(T,r)),!m))return y(r),x}if(!(j||b(a)&&b(u))){let r,t;const n=he(u),s=he(a);if(isNaN(l)){const a=e.valueAsDate||new Date(l);me(n.value)&&(r=a>new Date(n.value)),me(s.value)&&(t=a<new Date(s.value))}else{const a=e.valueAsNumber||parseFloat(l);b(n.value)||(r=a>n.value),b(s.value)||(t=a<s.value)}if((r||t)&&(S(!!r,n.message,s.message,C,F),!m))return y(x[o].message),x}if((n||s)&&!j&&me(l)){const e=he(n),r=he(s),t=!b(e.value)&&l.length>e.value,a=!b(r.value)&&l.length<r.value;if((t||a)&&(S(t,e.message,r.message),!m))return y(x[o].message),x}if(i&&!j&&me(l)){const{value:r,message:t}=he(i);if(pe(r)&&!l.match(r)&&(x[o]=Object.assign({type:N,message:t,ref:e},V(N,t)),!m))return y(t),x}if(c)if(de(c)){const e=be(await c(l),h);if(e&&(x[o]=Object.assign(Object.assign({},e),V(I,e.message)),!m))return y(e.message),x}else if(v(c)){let e={};for(const r in c){if(!M(e)&&!m)break;const t=be(await c[r](l),h,r);t&&(e=Object.assign(Object.assign({},t),V(r,t.message)),y(t.message),m&&(x[o]=e))}if(!M(e)&&(x[o]=Object.assign({ref:h},e),!m))return x}return y(!0),x},ye=e=>({isOnSubmit:!e||e===S,isOnBlur:e===j,isOnChange:e===V,isOnAll:e===A,isOnTouch:e===_}),xe=e=>e instanceof HTMLElement;class ke{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class Oe{constructor(e,r){this.observer=e,this.closed=!1,r.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class we{constructor(){this.observers=[]}next(e){for(const r of this.observers)r.next(e)}subscribe(e){const r=new ke,t=new Oe(e,r);return this.observers.push(t),r}unsubscribe(){this.observers=[]}}const je="undefined"==typeof window;function Ve({mode:e=S,reValidateMode:r=V,resolver:t,context:n,defaultValues:s={},shouldFocusError:a=!0,delayError:u,shouldUseNativeValidation:i,shouldUnregister:c,criteriaMode:l}={}){const[f,d]=o.exports.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}}),m=o.exports.useRef({isDirty:!U,dirtyFields:!U,touchedFields:!U,isValidating:!U,isValid:!U,errors:!U}),h=o.exports.useRef(t),j=o.exports.useRef(f),_=o.exports.useRef({}),C=o.exports.useRef(s),F=o.exports.useRef({}),D=o.exports.useRef(n),R=o.exports.useRef(!1),N=o.exports.useRef(!1),T=o.exports.useRef(),I=o.exports.useRef({watch:new we,control:new we,array:new we,state:new we}),H=o.exports.useRef({mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1}),Y=ye(e),q=l===A;h.current=t,D.current=n;const K=e=>H.current.watchAll||H.current.watch.has(e)||H.current.watch.has((e.match(/\w+/)||[])[0]),Q=(e,r)=>{$(j.current.errors,e,r),I.current.state.next({errors:j.current.errors})},Z=o.exports.useCallback((async(e,r,n,s,a,i)=>{const c=O(j.current.errors,r),o=!!m.current.isValid&&(t?a:await ge(_.current,!0));if(u&&n?(T.current=T.current||((e,r)=>{let t=0;return(...n)=>{clearTimeout(t),t=setTimeout((()=>e(...n)),r)}})(Q,u),T.current(r,n)):n?$(j.current.errors,r,n):ee(j.current.errors,r),(i||(n?!J(c,n,!0):c)||!M(s)||j.current.isValid!==o)&&!e){const e=Object.assign(Object.assign({},s),{isValid:!!o,errors:j.current.errors,name:r});j.current=Object.assign(Object.assign({},j.current),e),I.current.state.next(i?{name:r}:e)}I.current.state.next({isValidating:!1})}),[]),se=o.exports.useCallback(((e,r,t={},n,s)=>{s&&Ce(e);const a=O(_.current,e);if(a){const s=a._f;if(s){const a=P&&xe(s.ref)&&b(r)?"":r;if(s.value=ie(r,s),ne(s.ref)?(s.refs||[]).forEach((e=>e.checked=e.value===a)):re(s.ref)&&!me(a)?s.ref.files=a:te(s.ref)?[...s.ref.options].forEach((e=>e.selected=a.includes(e.value))):g(s.ref)&&s.refs?s.refs.length>1?s.refs.forEach((e=>e.checked=Array.isArray(a)?!!a.find((r=>r===e.value)):a===e.value)):s.refs[0].checked=!!a:s.ref.value=a,n){const t=z(_);$(t,e,r),I.current.control.next({values:Object.assign(Object.assign({},C.current),t),name:e})}(t.shouldDirty||t.shouldTouch)&&ue(e,a,t.shouldTouch),t.shouldValidate&&pe(e)}else a._f={ref:{name:e,value:r},value:r}}}),[]),ae=o.exports.useCallback(((e,r)=>{const t=z(_);return e&&r&&$(t,e,r),!J(t,C.current)}),[]),ue=o.exports.useCallback(((e,r,t,n=!0)=>{const s={name:e};let a=!1;if(m.current.isDirty){const e=j.current.isDirty;j.current.isDirty=ae(),s.isDirty=j.current.isDirty,a=e!==s.isDirty}if(m.current.dirtyFields&&!t){const t=O(j.current.dirtyFields,e);!J(O(C.current,e),r)?$(j.current.dirtyFields,e,!0):ee(j.current.dirtyFields,e),s.dirtyFields=j.current.dirtyFields,a=a||t!==O(j.current.dirtyFields,e)}const u=O(j.current.touchedFields,e);return t&&!u&&($(j.current.touchedFields,e,t),s.touchedFields=j.current.touchedFields,a=a||m.current.touchedFields&&u!==t),a&&n&&I.current.state.next(s),a?s:{}}),[]),ce=o.exports.useCallback((async(e,r)=>{const t=(await ve(O(_.current,e),q,i))[e];return await Z(r,e,t),k(t)}),[q]),oe=o.exports.useCallback((async e=>{const{errors:r}=await h.current(z(_),D.current,fe(H.current.mount,_.current,l,i));if(e)for(const t of e){const e=O(r,t);e?$(j.current.errors,t,e):ee(j.current.errors,t)}else j.current.errors=r;return r}),[l,i]),ge=async(e,r,t={valid:!0})=>{for(const n in e){const s=e[n];if(s){const e=s._f,n=E(s,"_f");if(e){const n=await ve(s,q,i);if(r){if(n[e.name]){t.valid=!1;break}}else n[e.name]?$(j.current.errors,e.name,n[e.name]):ee(j.current.errors,e.name)}n&&await ge(n,r,t)}}return t.valid},pe=o.exports.useCallback((async(e,r={})=>{const n=L(e);let s;if(I.current.state.next({isValidating:!0}),t){const r=await oe(k(e)?e:n);s=e?n.every((e=>!O(r,e))):M(r)}else e?s=(await Promise.all(n.filter((e=>O(_.current,e,{})._f)).map((async e=>await ce(e,!0))))).every(Boolean):(await ge(_.current),s=M(j.current.errors));return I.current.state.next(Object.assign(Object.assign({},me(e)?{name:e}:{}),{errors:j.current.errors,isValidating:!1})),r.shouldFocus&&!s&&X(_.current,(e=>O(j.current.errors,e)),e?n:H.current.mount),m.current.isValid&&he(),s}),[oe,ce]),be=(e,r,t)=>{const n=O(_.current,e);if(n){const s=k(n._f.value),a=s?k(O(F.current,e))?O(C.current,e):O(F.current,e):n._f.value;k(a)?s&&(n._f.value=le(n)):r&&r.defaultChecked?n._f.value=le(n):t?n._f.value=a:se(e,a)}N.current&&m.current.isValid&&he()},he=o.exports.useCallback((async(e={})=>{const r=t?M((await h.current(Object.assign(Object.assign({},z(_)),e),D.current,fe(H.current.mount,_.current,l,i))).errors):await ge(_.current,!0);r!==j.current.isValid&&(j.current.isValid=r,I.current.state.next({isValid:r}))}),[l,i]),ke=o.exports.useCallback(((e,r,t)=>Object.entries(r).forEach((([r,n])=>{const s=`${e}.${r}`,a=O(_.current,s);!H.current.array.has(e)&&G(n)&&(!a||a._f)||p(n)?se(s,n,t,!0,!a):ke(s,n,t)}))),[pe]),Oe=o.exports.useCallback((async({type:e,target:n,target:{value:s,name:a,type:u}})=>{const c=O(_.current,a);if(c){let f=u?le(c):void 0;f=k(f)?s:f;const d=e===w,{isOnBlur:m,isOnChange:p}=ye(r),b=(o=c._f,!(c._f.mount&&o&&(o.required||o.min||o.max||o.maxLength||o.minLength||o.pattern||o.validate)||t||O(j.current.errors,a))||(({isOnBlur:e,isOnChange:r,isOnTouch:t,isTouched:n,isReValidateOnBlur:s,isReValidateOnChange:a,isBlurEvent:u,isSubmitted:i,isOnAll:c})=>!c&&(!i&&t?!(n||u):(i?s:e)?!u:!(i?a:r)||u))(Object.assign({isBlurEvent:d,isTouched:!!O(j.current.touchedFields,a),isSubmitted:j.current.isSubmitted,isReValidateOnBlur:m,isReValidateOnChange:p},Y))),v=!d&&K(a);k(f)||(c._f.value=f);const x=ue(a,c._f.value,d,!1),V=!M(x)||v;if(b)return!d&&I.current.watch.next({name:a,type:e,values:Ve()}),V&&I.current.state.next(v?{name:a}:Object.assign(Object.assign({},x),{name:a}));I.current.state.next({isValidating:!0}),(async(e,r,n,s)=>{let a,u,c=e.name;const o=O(_.current,c);if(t){const{errors:r}=await h.current(z(_),D.current,fe([c],_.current,l,i));if(a=O(r,c),g(e)&&!a){const e=y(c),t=O(r,e,{});t.type&&t.message&&(a=t),(t||O(j.current.errors,e))&&(c=e)}u=M(r)}else a=(await ve(o,q,i))[c];!s&&I.current.watch.next({name:c,type:e.type,values:Ve()}),Z(!1,c,a,r,u,n)})(n,x,v,d)}var o}),[]),Ve=e=>{const r=Object.assign(Object.assign({},C.current),z(_));return k(e)?r:me(e)?O(r,e):e.map((e=>O(r,e)))},Se=o.exports.useCallback(((e,r,t,n)=>{const s=Array.isArray(e),a=n||N.current?Object.assign(Object.assign({},C.current),n||z(_)):k(r)?C.current:s?r:{[e]:r};if(k(e))return t&&(H.current.watchAll=!0),a;const u=[];for(const i of L(e))t&&H.current.watch.add(i),u.push(O(a,i));return s?u:u[0]}),[]),_e=(e,r={})=>{for(const t of e?L(e):H.current.mount)H.current.mount.delete(t),H.current.array.delete(t),O(_.current,t)&&(!r.keepError&&ee(j.current.errors,t),!r.keepValue&&ee(_.current,t),!r.keepDirty&&ee(j.current.dirtyFields,t),!r.keepTouched&&ee(j.current.touchedFields,t),!c&&!r.keepDefaultValue&&ee(C.current,t));I.current.watch.next({values:Ve()}),I.current.state.next(Object.assign(Object.assign({},j.current),r.keepDirty?{isDirty:ae()}:{})),!r.keepIsValid&&he()},Ae=(e,r,t)=>{Ce(e,t);let n=O(_.current,e);const s=(e=>ne(e)||g(e))(r);r===n._f.ref||s&&x(n._f.refs||[]).find((e=>e===r))||(n={_f:s?Object.assign(Object.assign({},n._f),{refs:[...x(n._f.refs||[]).filter((e=>xe(e)&&document.contains(e))),r],ref:{type:r.type,name:e}}):Object.assign(Object.assign({},n._f),{ref:r})},$(_.current,e,n),be(e,r))},Ce=o.exports.useCallback(((e,r={})=>{const t=O(_.current,e);return $(_.current,e,{_f:Object.assign(Object.assign(Object.assign({},t&&t._f?t._f:{ref:{name:e}}),{name:e,mount:!0}),r)}),H.current.mount.add(e),!t&&be(e,void 0,!0),je?{name:e}:{name:e,onChange:Oe,onBlur:Oe,ref:t=>{if(t)Ae(e,t,r);else{const t=O(_.current,e,{}),n=c||r.shouldUnregister;t._f&&(t._f.mount=!1,k(t._f.value)&&(t._f.value=t._f.ref.value)),n&&(!((e,r)=>[...e].some((e=>y(r)===e)))(H.current.array,e)||!R.current)&&H.current.unMount.add(e)}}}}),[]),Fe=o.exports.useCallback(((e,r)=>async n=>{n&&(n.preventDefault&&n.preventDefault(),n.persist&&n.persist());let s=!0,u=z(_);I.current.state.next({isSubmitting:!0});try{if(t){const{errors:e,values:r}=await h.current(u,D.current,fe(H.current.mount,_.current,l,i));j.current.errors=e,u=r}else await ge(_.current);M(j.current.errors)&&Object.keys(j.current.errors).every((e=>O(u,e)))?(I.current.state.next({errors:{},isSubmitting:!0}),await e(u,n)):(r&&await r(j.current.errors,n),a&&X(_.current,(e=>O(j.current.errors,e)),H.current.mount))}catch(c){throw s=!1,c}finally{j.current.isSubmitted=!0,I.current.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:M(j.current.errors)&&s,submitCount:j.current.submitCount+1,errors:j.current.errors})}}),[a,q,l,i]),De=(e,r="")=>{for(const t in e){const n=e[t],s=r+(r?".":"")+t,a=O(_.current,s);a&&a._f||(v(n)||Array.isArray(n)?De(n,s):a||Ce(s,{value:n}))}};return o.exports.useEffect((()=>{const e=I.current.state.subscribe({next(e){((e,r,t)=>{const n=E(e,"name");return M(n)||Object.keys(n).length>=Object.keys(r).length||Object.keys(n).find((e=>r[e]===(!t||A)))})(e,m.current,!0)&&(j.current=Object.assign(Object.assign({},j.current),e),d(j.current))}}),r=I.current.array.subscribe({next(e){if(e.values&&e.name&&m.current.isValid){const r=z(_);$(r,e.name,e.values),he(r)}}});return()=>{e.unsubscribe(),r.unsubscribe()}}),[]),o.exports.useEffect((()=>{const e=[],r=e=>!xe(e)||!document.contains(e);N.current||(N.current=!0,m.current.isValid&&he(),!c&&De(C.current));for(const t of H.current.unMount){const n=O(_.current,t);n&&(n._f.refs?n._f.refs.every(r):r(n._f.ref))&&e.push(t)}e.length&&_e(e),H.current.unMount=new Set})),{control:o.exports.useMemo((()=>({register:Ce,inFieldArrayActionRef:R,getIsDirty:ae,subjectsRef:I,watchInternal:Se,fieldsRef:_,updateIsValid:he,namesRef:H,readFormStateRef:m,formStateRef:j,defaultValuesRef:C,fieldArrayDefaultValuesRef:F,setValues:ke,unregister:_e,shouldUnmount:c})),[]),formState:B(U,f,m),trigger:pe,register:Ce,handleSubmit:Fe,watch:o.exports.useCallback(((e,r)=>de(e)?I.current.watch.subscribe({next:t=>e(Se(void 0,r),t)}):Se(e,r,!0)),[]),setValue:o.exports.useCallback(((e,r,t={})=>{const n=O(_.current,e),s=H.current.array.has(e);s&&(I.current.array.next({values:r,name:e,isReset:!0}),(m.current.isDirty||m.current.dirtyFields)&&t.shouldDirty&&($(j.current.dirtyFields,e,W(r,O(C.current,e,[]),O(j.current.dirtyFields,e,[]))),I.current.state.next({name:e,dirtyFields:j.current.dirtyFields,isDirty:ae(e,r)})),!r.length&&$(_.current,e,[])&&$(F.current,e,[])),(n&&!n._f||s)&&!b(r)?ke(e,r,s?{}:t):se(e,r,t,!0,!n),K(e)&&I.current.state.next({}),I.current.watch.next({name:e,values:Ve()})}),[ke]),getValues:o.exports.useCallback(Ve,[]),reset:o.exports.useCallback(((e,r={})=>{const t=e||C.current;if(P&&!r.keepValues)for(const s of H.current.mount){const e=O(_.current,s);if(e&&e._f){const r=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;try{xe(r)&&r.closest("form").reset();break}catch(n){}}}r.keepDefaultValues||(C.current=Object.assign({},t),F.current=Object.assign({},t)),r.keepValues||(_.current={},I.current.control.next({values:r.keepDefaultValues?C.current:Object.assign({},t)}),I.current.watch.next({values:Object.assign({},t)}),I.current.array.next({values:Object.assign({},t),isReset:!0})),H.current={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1},I.current.state.next({submitCount:r.keepSubmitCount?j.current.submitCount:0,isDirty:r.keepDirty?j.current.isDirty:!!r.keepDefaultValues&&J(e,C.current),isSubmitted:!!r.keepIsSubmitted&&j.current.isSubmitted,dirtyFields:r.keepDirty?j.current.dirtyFields:{},touchedFields:r.keepTouched?j.current.touchedFields:{},errors:r.keepErrors?j.current.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),N.current=!!r.keepIsValid}),[]),clearErrors:o.exports.useCallback((e=>{e?L(e).forEach((e=>ee(j.current.errors,e))):j.current.errors={},I.current.state.next({errors:j.current.errors})}),[]),unregister:o.exports.useCallback(_e,[]),setError:o.exports.useCallback(((e,r,t)=>{const n=((O(_.current,e)||{_f:{}})._f||{}).ref;$(j.current.errors,e,Object.assign(Object.assign({},r),{ref:n})),I.current.state.next({name:e,errors:j.current.errors,isValid:!1}),t&&t.shouldFocus&&n&&n.focus&&n.focus()}),[]),setFocus:o.exports.useCallback((e=>O(_.current,e)._f.ref.focus()),[])}}const Se=["I går","I dag","I morgen"],_e=()=>{const{register:e,watch:r}=Ve({mode:"onChange",defaultValues:{fieldName:Se[1]}}),t=r();return console.log(t),m("form",{onSubmit:e=>e.preventDefault(),children:m(f,{legend:"Velg dag",name:"fieldName",children:Se.map((r=>o.exports.createElement(d,c(i({},e("fieldName")),{value:r,label:r,key:r}))))})})},Ae={};function Ce(e){var r=e,{components:t}=r,u=((e,r)=>{var t={};for(var u in e)s.call(e,u)&&r.indexOf(u)<0&&(t[u]=e[u]);if(null!=e&&n)for(var u of n(e))r.indexOf(u)<0&&a.call(e,u)&&(t[u]=e[u]);return t})(r,["components"]);return l("wrapper",c(i(i({},Ae),u),{components:t,mdxType:"MDXLayout"}),l("h1",null,"RadioToggle"),l("p",null,"Hvis man setter showLegend til false vil den kun være der for screenreaders."),l(_e,{mdxType:"Example"}),l("pre",null,l("code",i({parentName:"pre"},{className:"language-tsx",metastring:"live=true",live:"true"}),'<FieldSet\n  legend="Is The Room the greatest movie ever"\n  name="the-room"\n  showLegend="true"\n>\n  <RadioToggleInput\n    value={0}\n    label="Yes"\n  />\n  <RadioToggleInput\n    value={1}\n    label="No"\n  />\n</FieldSet>\n')),l("pre",null,l("code",i({parentName:"pre"},{className:"language-tsx",metastring:"live=true",live:"true"}),'<RadioToggleInput\n  value={0}\n  label="Yes"\n  name="demo"\n/>\n')),l("h2",null,"Controlled component"),l("p",null,"Hvis du ønsker å bruke komponenten direkte som en kontrollert komponent kan det gjøres\nved å gi hver ",l("inlineCode",{parentName:"p"},"RadioToggleInput")," en ",l("inlineCode",{parentName:"p"},"checked")," verdi og ",l("inlineCode",{parentName:"p"},"onChange")," handler.\n",l("inlineCode",{parentName:"p"},"name")," settes på fieldsetet rundt."),l("pre",null,l("code",i({parentName:"pre"},{className:"language-tsx"}),'const [value, setValue] = useState(1);\n\nconst changeValue = (e) => {\n  setValue(parseFloat(e.target.value));\n}\n\nreturn (\n  <FieldSet\n    legend="Is The Room the greatest movie ever"\n    name="the-room"\n  >\n    <RadioToggleInput\n      value={0}\n      checked={value === 0}\n      onChange={changeValue}\n      label="Yes"\n    />\n    <RadioToggleInput\n      value={1}\n      checked={value === 1}\n      onChange={changeValue}\n      label="No"\n    />\n  </FieldSet>\n);\n')),l("h2",null,"Uncontrolled"),l("p",null,"Den kan også brukes som en ukontrollert komponent. Du kan gi referanse til både fieldsetet og inputene for\nå ta ut verdiene."),l("pre",null,l("code",i({parentName:"pre"},{className:"language-tsx"}),'<FieldSet\n  legend="Is The Room the greatest movie ever"\n  name="the-room"\n>\n  <RadioToggleInput\n    value={0}\n    label="Yes"\n  />\n  <RadioToggleInput\n    value={1}\n    label="No"\n  />\n</FieldSet>\n')),l("h2",null,"Uncontrolled with react-hook-form"),l("p",null,"Det er kanskje mest interessant sammen med et form-bibliotek som  ",l("inlineCode",{parentName:"p"},"react-hook-form"),".\nDa register du hvert enkelt input felt med register funksjonen. Det må ha samme navn som du gir til fieldsetet."),l("pre",null,l("code",i({parentName:"pre"},{className:"language-tsx"}),'const {\n  register,\n  handleSubmit,\n} = useForm();\nconst onSubmit = data => console.log(data);\n\nreturn (\n  <form onSubmit={handleSubmit(onSubmit)}>\n    <FieldSet\n      legend="Is The Room the greatest movie ever"\n      name="the-room"\n    >\n      <RadioToggleInput\n        {...register(\'the-room\')}\n        value="0"\n        label="Yes"\n      />\n      <RadioToggleInput\n        {...register(\'the-room\')}\n        value="1"\n        label="No"\n      />\n    </FieldSet>\n    <PrimaryButton type="submit">\n      Send inn\n    </PrimaryButton>\n  </form>\n);\n')))}Ce.isMDXComponent=!0;export default Ce;
